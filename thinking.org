#+STARTUP: showeverything
* Subsystems
** Rendering
   Using openGL for this. We basically just need to build a "sprite
   interpreter", so to speak, where a "sprite" is just a 2D
   graphical... thing. So we should get a specification for sprites going so
   that we can use them.

   Also, here's the [[https://wiki.libsdl.org/CategoryVideo][SDL video documentation]].
*** Specification
    So what are sprites made up of, and how should they be rendered based on
    that?

    In general, 2D images are either vector graphics or bitmaps (that is, a
    2-dimensional array of color values). So a sprite should be able to have
    both of those. First we copy the bitmap to the framebuffer, then we draw the
    vector parts on top of it. The bitmap parts should be pretty simple - RGBA,
    each component 8 bits. The vector parts are more tricky - what should they
    consist of? Lines, curves, and regions I think. More generally, vector
    graphics can be specified as paths and regions enclosed by paths. 
**** Paths
     In the general case, a path can always be created as a sequence of
     lines. It might take a lot of them to make a good approximation, but it can
     be done. But it might also be useful to have other ways of specifying
     them. For example, as a parametric function with a certain start and end
     time. The question is just how to determine efficiently in the general case
     what is enclosed by a path.
** Physics
*** Collision detection
    The simplest thing that could possibly sort of work: Everything is a box,
    teleport everything to where its velocity and the elapsed time indicate it
    should be, and figure out what stuff is stuck in each other.
*** Actual physics
**** Describing motion
     Forces are instantaneous and applied each physics update, and velocities
     are constant in between updates. Position is incremented by whatever the
     combination of change in time and current velocity indicate it should be. 
**** Collision response
     The simplest form involves stuff hitting each other and sticking (that is,
     not bouncing) and combining the momentums to figure out how fast and in
     what direction they should be going now. Bouncing is hard because figuring
     out the angle of incidence is hard when you don't actually know where or
     when they collided (although it's easier with boxes than with other
     shapes).
** Game logic

* Project organization
  So far we've just got main.c, which has the basic everything loop, a Makefile
  to be used for compiling, and this document that is, as the name implies, for
  thinking. 
* Documentation
  [[https://wiki.libsdl.org][SDL wiki]]
** Building
   If you're on Linux or really any Unix, this should be pretty
   straightforward. Just make sure you have libsdl2-dev or whatever your package
   manager calls it, make, and gcc of course installed. If you're using mingw32,
   you want the msys version of make - the one that comes already installed
   won't work. If you're on windows and want to use anything other than mingw, I
   don't know what you should do, but you're probably smarter than me so you can
   probably figure it out.

* Schedule/TODOs
** NOTE: If you want something immediately visible, put a flush() after it!
   On Windows especially, the buffering of stdout is really obvious - you'd
   think we weren't even getting any events until suddenly the buffer is full
   and gets autoflushed and suddenly we get 200 lines of output. Note that this
   doesn't seem to have the intended effect in Windows - it still only prints
   big chunks at a time.
